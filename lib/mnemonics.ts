export type MnemonicEntry = { mnemonic: string; description: string; example?: string };

export const MNEMONICS_8086: MnemonicEntry[] = [
  { mnemonic: 'MOV', description: 'Move data between registers or memory', example: 'MOV AX, BX    ; copy BX into AX' },
  { mnemonic: 'XCHG', description: 'Exchange data between registers', example: 'XCHG AX, BX   ; swap AX and BX' },
  { mnemonic: 'PUSH', description: 'Push data onto stack', example: 'PUSH AX       ; push AX onto stack' },
  { mnemonic: 'POP', description: 'Pop data from stack', example: 'POP BX        ; pop top of stack into BX' },
  { mnemonic: 'IN', description: 'Read from I/O port', example: 'IN AL, 0x60   ; read from port 0x60 into AL' },
  { mnemonic: 'OUT', description: 'Write to I/O port', example: 'OUT 0x60, AL  ; write AL to port 0x60' },
  { mnemonic: 'LEA', description: 'Load effective address', example: 'LEA SI, [BX+5] ; load address into SI' },
  { mnemonic: 'LDS', description: 'Load DS with pointer', example: 'LDS BX, ptr   ; load DS:BX from pointer' },
  { mnemonic: 'LES', description: 'Load ES with pointer', example: 'LES DI, ptr   ; load ES:DI from pointer' },
  { mnemonic: 'ADD', description: 'Add', example: 'ADD AX, BX    ; AX = AX + BX' },
  { mnemonic: 'ADC', description: 'Add with carry', example: 'ADC AX, BX    ; AX = AX + BX + CF' },
  { mnemonic: 'SUB', description: 'Subtract', example: 'SUB AX, 1     ; AX = AX - 1' },
  { mnemonic: 'SBB', description: 'Subtract with borrow', example: 'SBB AX, BX    ; AX = AX - BX - CF' },
  { mnemonic: 'INC', description: 'Increment', example: 'INC CX        ; CX = CX + 1' },
  { mnemonic: 'DEC', description: 'Decrement', example: 'DEC CX        ; CX = CX - 1' },
  { mnemonic: 'MUL', description: 'Unsigned multiply', example: 'MUL BX        ; AX = AX * BX (unsigned)' },
  { mnemonic: 'IMUL', description: 'Signed multiply', example: 'IMUL BX       ; AX = AX * BX (signed)' },
  { mnemonic: 'DIV', description: 'Unsigned divide', example: 'DIV BL        ; divide AX by BL -> AL=quotient' },
  { mnemonic: 'IDIV', description: 'Signed divide', example: 'IDIV BL       ; signed divide' },
  { mnemonic: 'NEG', description: "Two's complement", example: 'NEG AX        ; AX = -AX' },
  { mnemonic: 'CMP', description: 'Compare (sets flags)', example: 'CMP AX, BX    ; set flags for AX - BX' },
  { mnemonic: 'DAA', description: 'Decimal adjust after add', example: 'DAA           ; adjust AL after BCD add' },
  { mnemonic: 'DAS', description: 'Decimal adjust after sub', example: 'DAS           ; adjust AL after BCD sub' },
  { mnemonic: 'AND', description: 'Logical AND', example: 'AND AX, BX    ; bitwise AND' },
  { mnemonic: 'OR', description: 'Logical OR', example: 'OR AX, BX     ; bitwise OR' },
  { mnemonic: 'XOR', description: 'Logical XOR', example: 'XOR AX, AX    ; zero AX' },
  { mnemonic: 'NOT', description: 'Logical NOT', example: 'NOT AX        ; bitwise NOT' },
  { mnemonic: 'TEST', description: 'Logical AND for flags only', example: 'TEST AX, BX   ; set flags, no dest' },
  { mnemonic: 'SHL', description: 'Shift left', example: 'SHL AX, 1     ; shift left' },
  { mnemonic: 'SAL', description: 'Shift left (alias)', example: 'SAL AX, 1     ; same as SHL' },
  { mnemonic: 'SHR', description: 'Shift right', example: 'SHR AX, 1     ; logical shift right' },
  { mnemonic: 'ROL', description: 'Rotate left', example: 'ROL AX, 1     ; rotate left through MSB' },
  { mnemonic: 'ROR', description: 'Rotate right', example: 'ROR AX, 1     ; rotate right' },
  { mnemonic: 'RCL', description: 'Rotate through carry left', example: 'RCL AX, 1     ; rotate through carry' },
  { mnemonic: 'RCR', description: 'Rotate through carry right', example: 'RCR AX, 1     ; rotate through carry' },
  { mnemonic: 'JMP', description: 'Unconditional jump', example: 'JMP 0x100    ; jump to address 0x100' },
  { mnemonic: 'CALL', description: 'Call subroutine', example: 'CALL myFunc   ; call procedure' },
  { mnemonic: 'RET', description: 'Return from subroutine', example: 'RET           ; return' },
  { mnemonic: 'JE', description: 'Jump if equal / zero', example: 'JE equalLabel ; jump if ZF set' },
  { mnemonic: 'JNE', description: 'Jump if not equal / not zero', example: 'JNE label     ; jump if ZF clear' },
  { mnemonic: 'JC', description: 'Jump if carry', example: 'JC carryLabel ; jump if CF set' },
  { mnemonic: 'JNC', description: 'Jump if no carry', example: 'JNC label     ; jump if CF clear' },
  { mnemonic: 'HLT', description: 'Halt processor', example: 'HLT           ; stop execution' },
  { mnemonic: 'NOP', description: 'No operation', example: 'NOP           ; do nothing' },
];

export const MNEMONICS_8051: MnemonicEntry[] = [
  { mnemonic: 'MOV', description: 'Move data between registers, memory, or immediate values', example: 'MOV A, #0x12  ; load immediate into A' },
  { mnemonic: 'MOVC', description: 'Move code byte (A with DPTR/PC)', example: 'MOVC A, @A+DPTR ; read code byte' },
  { mnemonic: 'MOVX', description: 'Move external data (external memory)', example: 'MOVX A, @DPTR ; read external memory into A' },
  { mnemonic: 'PUSH', description: 'Push data onto stack', example: 'PUSH ACC      ; push accumulator' },
  { mnemonic: 'POP', description: 'Pop data from stack', example: 'POP ACC       ; pop into accumulator' },
  { mnemonic: 'XCH', description: 'Exchange accumulator with register or memory', example: 'XCH A, R0     ; swap A and R0' },
  { mnemonic: 'XCHD', description: 'Exchange accumulator with lower nibble of memory', example: 'XCHD A, @R0   ; swap lower nibble' },
  { mnemonic: 'SWAP', description: 'Swap nibbles of accumulator', example: 'SWAP A       ; swap high/low nibble of A' },
  { mnemonic: 'ADD', description: 'Add', example: 'ADD A, R0     ; A = A + R0' },
  { mnemonic: 'ADDC', description: 'Add with carry', example: 'ADDC A, R0    ; A = A + R0 + CY' },
  { mnemonic: 'SUBB', description: 'Subtract with borrow', example: 'SUBB A, #0x1  ; A = A - 1 - CY' },
  { mnemonic: 'INC', description: 'Increment', example: 'INC R0        ; R0 = R0 + 1' },
  { mnemonic: 'DEC', description: 'Decrement', example: 'DEC R0        ; R0 = R0 - 1' },
  { mnemonic: 'MUL', description: 'Multiply A by B (MUL AB)', example: 'MUL AB        ; A*B -> B:A' },
  { mnemonic: 'DIV', description: 'Divide A by B (DIV AB)', example: 'DIV AB        ; A/B -> A:quotient B:remainder' },
  { mnemonic: 'DA', description: 'Decimal adjust accumulator', example: 'DA A          ; adjust A after BCD addition' },
  { mnemonic: 'ANL', description: 'Logical AND', example: 'ANL A, #0x0F ; A = A & 0x0F' },
  { mnemonic: 'ORL', description: 'Logical OR', example: 'ORL A, #0x01 ; A = A | 0x01' },
  { mnemonic: 'XRL', description: 'Logical XOR', example: 'XRL A, R0     ; A = A ^ R0' },
  { mnemonic: 'CPL', description: "Complement (1's complement) / complement bit", example: 'CPL A         ; A = ~A' },
  { mnemonic: 'CLR', description: 'Clear bit or register', example: 'CLR A         ; A = 0' },
  { mnemonic: 'RL', description: 'Rotate accumulator left', example: 'RL A          ; rotate left' },
  { mnemonic: 'RLC', description: 'Rotate accumulator left through carry', example: 'RLC A         ; rotate through carry' },
  { mnemonic: 'RR', description: 'Rotate accumulator right', example: 'RR A          ; rotate right' },
  { mnemonic: 'RRC', description: 'Rotate accumulator right through carry', example: 'RRC A         ; rotate through carry' },
  { mnemonic: 'SJMP', description: 'Short jump (within 128 bytes)', example: 'SJMP label    ; short jump' },
  { mnemonic: 'AJMP', description: 'Absolute jump (within 2K block)', example: 'AJMP addr     ; absolute jump' },
  { mnemonic: 'LJMP', description: 'Long jump (anywhere in 64K)', example: 'LJMP addr     ; long jump' },
  { mnemonic: 'ACALL', description: 'Absolute call (within 2K block)', example: 'ACALL subr    ; call subroutine' },
  { mnemonic: 'LCALL', description: 'Long call (anywhere in 64K)', example: 'LCALL subr    ; long call' },
  { mnemonic: 'RET', description: 'Return from subroutine', example: 'RET           ; return' },
  { mnemonic: 'RETI', description: 'Return from interrupt', example: 'RETI          ; return from interrupt' },
  { mnemonic: 'JC', description: 'Jump if carry set', example: 'JC label      ; jump if CY=1' },
  { mnemonic: 'JNC', description: 'Jump if carry not set', example: 'JNC label     ; jump if CY=0' },
  { mnemonic: 'JZ', description: 'Jump if accumulator zero', example: 'JZ label      ; jump if A==0' },
  { mnemonic: 'JNZ', description: 'Jump if accumulator not zero', example: 'JNZ label     ; jump if A!=0' },
  { mnemonic: 'CJNE', description: 'Compare and jump if not equal', example: 'CJNE A, #0x1, label ; compare and jump' },
  { mnemonic: 'DJNZ', description: 'Decrement and jump if not zero', example: 'DJNZ R0, label ; decrement and jump if not zero' },
  { mnemonic: 'NOP', description: 'No operation', example: 'NOP           ; do nothing' },
  { mnemonic: 'SETB', description: 'Set bit', example: 'SETB P1.0     ; set port bit' },
  { mnemonic: 'JBC', description: 'Jump if bit set and clear bit', example: 'JBC bit,label  ; jump if bit set then clear' },
  { mnemonic: 'MOVX', description: 'External RAM access (duplicate entry handled)', example: 'MOVX @DPTR, A ; write A to external RAM' },
];

export function getMnemonicsFor(processor: '8086' | '8051') {
  return processor === '8051' ? MNEMONICS_8051 : MNEMONICS_8086;
}

export default MNEMONICS_8086;
